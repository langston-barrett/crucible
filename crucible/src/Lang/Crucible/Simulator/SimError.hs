-----------------------------------------------------------------------
-- |
-- Module           : Lang.Crucible.Simulator.SimError
-- Description      : Data structure the execution state of the simulator
-- Copyright        : (c) Galois, Inc 2014
-- License          : BSD3
-- Maintainer       : Joe Hendrix <jhendrix@galois.com>
-- Stability        : provisional
------------------------------------------------------------------------
{-# LANGUAGE CPP #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE PatternGuards #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
module Lang.Crucible.Simulator.SimError (
    SimErrorReason(..)
  , SimError(..)
  , simErrorReasonMsg
  , makeSimError
  , ppSimError
  ) where

import Control.Exception
import Data.String
import Data.Typeable
import Text.PrettyPrint.ANSI.Leijen hiding ((<$>))
import GHC.Stack

import What4.ProgramLoc
import What4.Interface (IsExprBuilder, getCurrentProgramLoc)

------------------------------------------------------------------------
-- SimError

-- | Class for exceptions generated by simulator.
data SimErrorReason
   = GenericSimError !String
   | Unsupported !String -- ^ We can't do that (yet?)
   | ReadBeforeWriteSimError !String -- FIXME? include relevant data instead of a string?
   | AssertFailureSimError !String
   | ResourceExhausted String
      -- ^ A loop iteration count, or similar resource limit,
      --   was exceeded.
 deriving (Eq, Ord, Typeable)

data SimError
   = SimError
   { simErrorLoc        :: !ProgramLoc
   , simErrorStackTrace :: ![String]
     -- ^ A GHC profiling stack trace, for debugging internal errors.
   , simErrorReason     :: !SimErrorReason
   }
 deriving (Eq, Ord, Typeable)

simErrorReasonMsg :: SimErrorReason -> String
simErrorReasonMsg (GenericSimError msg) = msg
simErrorReasonMsg (Unsupported msg) = "Unsupported feature: " ++ msg
simErrorReasonMsg (ReadBeforeWriteSimError msg) = msg
simErrorReasonMsg (AssertFailureSimError msg) = msg
simErrorReasonMsg (ResourceExhausted msg) = "Resource exhausted: " ++ msg

instance IsString SimErrorReason where
  fromString = GenericSimError

instance Show SimErrorReason where
  show = simErrorReasonMsg

instance Show SimError where
  show = show . ppSimError 1

-- | Create a 'SimError' with a profiling stack trace (if one is available)
makeSimError :: IsExprBuilder sym => sym -> SimErrorReason -> IO SimError
makeSimError sym reason =
  (\loc st -> SimError { simErrorLoc        = loc
                       , simErrorReason     = reason
                       -- drop this frame so 'makeSimError' isn't in the stack
                       , simErrorStackTrace = take (length st - 1) st
                       })
  <$> getCurrentProgramLoc sym
  <*> currentCallStack

ppSimError :: Int -> SimError -> Doc
ppSimError verbosity er =
  vcat $ [ vcat (text <$> lines (show (simErrorReason er)))
         , text "in" <+> text (show (plFunction loc)) <+> text "at" <+> text (show (plSourceLoc loc))
         ] ++ if | verbosity > 2 && not (null (simErrorStackTrace er)) ->
                   [ text "Stack trace:"
                   , vcat (map text (simErrorStackTrace er))
                   ]
                 | verbosity > 2 -> -- The stack trace is null
                   [ text "Empty call stack!"
                   , hcat . map text $
                     [ "Hint: Crucible must be compiled with profiling for"
                     , "stack traces."
                     ]
                   ]
                 | otherwise ->
                   [ hcat . map text $
                     [ "(for a complete stack trace,"
                     , "try increasing the verbosity)"
                     ]
                   ]
 where loc = simErrorLoc er

instance Exception SimError
